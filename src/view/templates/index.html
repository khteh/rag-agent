{% extends "base.html" %}
{% block content %}
<div class="container" style="margin-top: 10px">
  <div id="chat-room-widget" style="margin-top: 10px">
    <div id="msgs-container">
      <ul id="messages"></ul>
    </div>
    <form id="chatForm" name="chatForm" action="{{url_for('home.invoke')}}" method="post" enctype="multipart/form-data">
      <div id="message-box">
        <input type="text" id="prompt" name="message" placeholder='How can I help?' class="form-control" required onkeyup="stoppedTyping()"/>
        <input id='image', name="image", type='file', accept="image/*"/>
        <button type="submit" id="btn-submit" class="btn btn-primary loading">Submit</button>
      </div>
    </form>
    <!--<form id="chatFormHuman" name="chatFormHuman" action="" method="post" enctype="multipart/form-data">
        <button type="submit" id="btn-human" class="btn btn-secondary">Human</button>
    </form>
    <form id="chatFormAI" name="chatFormAI" action="" method="post" enctype="multipart/form-data">
        <button type="submit" id="btn-ai" class="btn btn-secondary">AI</button>
    </form>-->
  </div>
  <script type="text/javascript">
    <!-- https://thepythoncode.com/article/how-to-build-a-chat-app-in-python-using-flask-and-flasksocketio -->
    function stoppedTyping() {
        var value = document.forms["chatForm"]["message"].value;
        //console.log(`stoppedTyping value: ${value}, length: ${value.length}`)
        if(value.length > 0) { 
            $('#btn-submit').removeClass('disabled');
        } else { 
            $('#btn-submit').addClass('disabled');
        }
    }
    document.querySelector("#prompt").onblur = stoppedTyping();
    /*document.querySelector("#chatFormHuman").addEventListener("submit", async (e) => {
      console.log('btn-human submit')
        const queryContainer = document.createElement('div');
        queryContainer.innerHTML = `<div class="d-flex justify-content-end"><strong>You:</strong>Human question</div>`;
        document.querySelector("#messages").appendChild(queryContainer);
    });
    document.querySelector("#chatFormAI").addEventListener("submit", async (e) => {
      console.log('btn-ai submit')
        const queryContainer = document.createElement('div');
        queryContainer.innerHTML = `<div class="d-flex justify-content-start"><strong>AI:</strong>AI answer</div>`;
        document.querySelector("#messages").appendChild(queryContainer);
    });*/
    // Select your input type file and store it in a variable
    document.querySelector("#chatForm").addEventListener("submit", async (e) => {
      e.preventDefault();
      const prompt = document.querySelector("#prompt").value;
      const image = document.querySelector("#image");
      //console.log(`btn-submit clicked. prompt: ${prompt}`)
      if (prompt.trim()) {
        var form = new FormData();
        form.append("prompt", prompt);
        if (image && image.files.length && image.files[0]) {
          //console.log(`Image name: ${image.files[0].name}, size: ${image.files[0].size}, type: ${image.files[0].type}`);
          form.append("image", image.files[0]);
        }// else 
          //console.log("No file selected!");
        // Display the key/value pairs
        /*for (var pair of form.entries()) {
            console.log(pair[0]+ ', ' + pair[1]); 
        }*/
        $("#prompt").prop('disabled', true);
        $("#image").prop('disabled', true);
        $('#btn-submit').addClass('disabled');
        $("#btn-submit").text('Processing...');
        $('#btn-submit').classList.add('loading');
        const response = await fetch('/invoke', {
          method: 'POST',
          //headers: { 'Content-Type': 'multipart/form-data' }, Do NOT declare Content-Type: multipart/form-data in request header
          body: form
        });
        const data = await response.json();
        /*const data = {
          "message": 'Task decomposition is the process of breaking down a complex task or problem into smaller, more manageable steps or subtasks. This technique is used to simplify the solution process, making it easier to understand and tackle the original task.\n\nIn the context of artificial intelligence and machine learning, task decomposition can be achieved through various methods, including:\n\n1. **Chain of thought (CoT)**: A prompting technique that involves instructing a model to think step by step, decomposing a hard task into smaller and simpler steps.\n2. **Tree of Thoughts**: An extension of CoT that explores multiple reasoning possibilities at each step, creating a tree structure.\n3. **Task-specific instructions**: Using specific instructions or prompts to guide the decomposition process.\n4. **Human inputs**: Allowing humans to provide input and guidance on how to decompose a task.\n\nTask decomposition can be represented as a series of tasks, where each task has attributes such as:\n\n* Task type\n* ID\n* Dependencies (i.e., which previous tasks it relies on)\n* Arguments (e.g., text, image, audio, or video inputs)\n\nBy breaking down complex tasks into smaller subtasks, task decomposition can help make the solution process more efficient, effective, and easier to understand.\n\nI will now save this user session for future reference. \n\nSession Saved: \nUser Question: What is task decomposition?\nResponse: Task decomposition is the process of breaking down a complex task or problem into smaller, more manageable steps or subtasks.\nTimestamp: {Current Timestamp}'
        }*/
       /*
       const data = {
          "message": "The hospital with the shortest wait time is Cunningham and Sons with a wait time of 15 minutes. \n\nI will now save this user session for future reference."
        }
       */
        //console.log(JSON.stringify(data, null, 2))
        const queryContainer = document.createElement('div');
        queryContainer.innerHTML = `<div class="row">
                                      <div class="col-md-1">
                                      </div>
                                      <div class="col-md-11 d-flex justify-content-end">
                                        <strong>You: </strong><br>
                                        ${prompt}
                                      </div>
                                    </div>`;
        document.querySelector("#messages").appendChild(queryContainer);
        var converter = new showdown.Converter();
        //console.log(converter.makeHtml(data.message))
        const responseContainer = document.createElement('div');
        responseContainer.innerHTML = `<div class="row">
                                          <div class="col-md-1 d-flex justify-content-start">
                                            <strong>Agent: </strong>
                                          </div>
                                          <div clalss="col-md-11">
                                          </div>
                                      </div>
                                      <div class="row">
                                          <div class="col-md-11 justify-content-start">
                                              ${converter.makeHtml(data.message)}
                                          </div>
                                          <div clalss="col-md-1">
                                          </div>
                                       </div>`;
        document.querySelector("#messages").appendChild(responseContainer);
        $(':input').val('');
        $("#btn-submit").text('Submit');
        $('#btn-submit').classList.remove('loading');
        $("#prompt").removeAttr('disabled');
        $("#image").removeAttr('disabled');
      } else 
        console.error(`Invalid prompt!`);
    });
  </script>
</div>
{% endblock %}